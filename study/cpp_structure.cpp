/**
 * @file cpp_structure.c
 * @author yongjule
 * @brief cpp structure to compare with c structure
 * @date 2022-02-15
 */

#include <iostream>
#include <string>


struct Student {
	int num;
	int setted;
	void Set(int tmp) { setted = tmp; } // 1. cpp에서 멤버 함수 가능
	static int x; // 2. cpp 에서 static 변수 가능
	Student(int x) { num = x; } // 3. constructer
	//int init = 42; // 4. 선언과 동시에 초기화도 가능, 근데 c++11임
	private: // 6. cpp 는 access modifier 사용 가능
	int private_num;
	public:
	void SetPrivate(int tmp) { private_num = tmp; }
	void getPrivate() { std::cout << "generated by Private num is " << private_num << std::endl; }
};

// struct도 상속받을 수 있음
struct yongjule : Student {
	private:
	int private_num;
	public:
	yongjule(int x) : Student(x) { private_num = x; }
	void setPrivate_struct(int tmp) { private_num = tmp; }
	void getPrivate_struct() { std::cout << "generated by Private num in yongjule is " << private_num << std::endl; }
};

int Student::x = 53; // 2. 이런식으로 초기화. js의 class static와 같네

int main(int argc, char** argv) {
	// struct Student s1;
	Student s1 = 10; // s1(10)과 같음, 5. struct를 앞에 안붙여도 됨
	Student* s2 = &s1;
	Student& s3 = s1; // 레퍼런스 가능
	s1.Set(1);
	std::cout << "generated by Set() is " << s1.setted << std::endl;
	std::cout << "generated by constructer is " << s1.num << std::endl;
	std::cout << "generated by static is " << s1.x << std::endl;
	// std::cout << "generated by private_num" << s1.private_num << std::endl; // 6. private_num은 접근 불가능
	s1.SetPrivate(4242);
	s1.getPrivate();
	s3.SetPrivate(424242);
	s1.getPrivate();
	s3.getPrivate();
	s2->SetPrivate(42);
	s2->getPrivate();
	s3.getPrivate();

	yongjule yj(1);
	yj.setPrivate_struct(4);
	yj.getPrivate_struct();
	yj.getPrivate();
	std::cout << yj.x << std::endl;
	// std::cout << "generated by init is " << s1.init << std::endl;
	return 0;
}